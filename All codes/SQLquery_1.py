import os
import json
import sqlite3
import autogen
from autogen import AssistantAgent, GroupChat, GroupChatManager
from dotenv import load_dotenv
from typing_extensions import Annotated

# Load environment variables
load_dotenv()

# Constants
DATABASE_PATH = r'C:\Users\sanan\DP_Agents\Persona.db'
JSON_FILE_PATH = r'C:\Users\sanan\DP_Agents\metadata.json'

logging_session_id = autogen.runtime_logging.start(config={"dbname": "empty_database.db"})
print("Logging session ID: " + str(logging_session_id))

# Termination condition function
termination_msg = lambda x: isinstance(x, dict) and "TERMINATE" == str(x.get("content", ""))[-9:].upper()

llm_config = {
    "timeout": 600,
    "cache_seed": 44,
    "config_list": [{"model": "gpt-3.5-turbo", "api_key": os.environ["OPENAI_API_KEY"]}],
    "temperature": 0
}

# Define agents for interaction
manager_system_message = """
Manager. You interact with the user and delegate tasks to other agents based on the queries received. You cannot terminate without the user's consent.
"""
manager_agent = AssistantAgent(
    name="Manager",
    system_message=manager_system_message,
    is_termination_msg=termination_msg,
    code_execution_config=False,
    llm_config=llm_config,
    default_auto_reply="Reply TERMINATE if the task is done.",
    human_input_mode="ALWAYS",
)

sqluser_system_message = """
SQLuser. Based on the question from the manager_agent and existing database and metadata, you create relevant SQLite queries. You will not terminate the conversation by yourself.
"""
sqluser = AssistantAgent(
    name="SQLuser",
    system_message=sqluser_system_message,
    is_termination_msg=termination_msg,
    code_execution_config=False,
    llm_config=llm_config,
)

analyst_system_message = """
Analyst. You execute the queries generated by SQLuser, analyze the data, and provide results to the Manager for communication with the user. You will not terminate the conversation by yourself.
"""
analyst = AssistantAgent(
    name="Analyst",
    system_message=analyst_system_message,
    is_termination_msg=termination_msg,
    code_execution_config=False,
    llm_config=llm_config,
)

def call_rag_chat(problem_statement):
    def fetch_metadata(json_file_path: Annotated[str, "Path to JSON metadata file"]) -> dict:
        with open(json_file_path, 'r') as file:
            metadata = json.load(file)
        return metadata

    def fetch_table_details(table_name: str, database_path: str = DATABASE_PATH) -> dict:
        conn = sqlite3.connect(database_path)
        cursor = conn.cursor()

        # Fetch column details
        cursor.execute(f"PRAGMA table_info({table_name})")
        columns = cursor.fetchall()
        column_names = [col[1] for col in columns]

        # Fetch primary key
        primary_key = [col[1] for col in columns if col[5] == 1]

        # Fetch foreign keys
        cursor.execute(f"PRAGMA foreign_key_list({table_name})")
        foreign_keys = cursor.fetchall()

        conn.close()

        table_details = {
            "table_name": table_name,
            "columns": column_names,
            "primary_key": primary_key,
            "foreign_keys": foreign_keys
        }

        return table_details

    def execute_query(query: str, database_path: str = DATABASE_PATH) -> list:
        connection = sqlite3.connect(database_path)
        cursor = connection.cursor()
        try:
            cursor.execute(query)
            results = cursor.fetchall()
            return results
        except Exception as e:
            return str(e)
        finally:
            cursor.close()
            connection.close()

    # Reset agents
    manager_agent.reset()
    sqluser.reset()
    analyst.reset()

    # Register functions with specific agents for language model usage
    for agent_work in [manager_agent, sqluser, analyst]:
        agent_work.register_for_llm(description="Fetch metadata from JSON file.", api_style="function")(fetch_metadata)
        agent_work.register_for_llm(description="Fetch table details from SQLite database.", api_style="function")(
            fetch_table_details)
        agent_work.register_for_llm(description="Execute SQL queries on the SQLite database.", api_style="function")(
            execute_query)

    # Register functions for execution with relevant agents
    for executor in [manager_agent, sqluser, analyst]:
        executor.register_for_execution()(fetch_metadata)
        executor.register_for_execution()(fetch_table_details)
        executor.register_for_execution()(execute_query)

    groupchat = GroupChat(
        agents=[manager_agent, sqluser, analyst],
        messages=[],
        max_round=12,
        speaker_selection_method="round_robin",
        allow_repeat_speaker=False,
    )

    manager = GroupChatManager(groupchat=groupchat, llm_config=llm_config)

    while True:
        manager_agent.initiate_chat(manager, message=problem_statement)
        user_input = input("Provide feedback to chat_manager. Type 'exit' to end the conversation: ")
        if user_input.lower() == 'exit':
            break
        manager_agent.send_message(manager, message=user_input)

# Example usage
if __name__ == "__main__":
    problem_statement = "What relevant questions can be asked to extract important data from this database?"
    call_rag_chat(problem_statement)
