import os
import json
import sqlite3
import autogen
from autogen import AssistantAgent, GroupChat, GroupChatManager
from dotenv import load_dotenv
from typing import List, Dict, Any
from typing_extensions import Annotated

# Load environment variables
load_dotenv()

# Constants
DATABASES = [
    {"path": 'Persona.db', "metadata": 'metadata.json'},
    {"path": 'Suppliers.db', "metadata": 'supplier_metadata.json'}
]

logging_session_id = autogen.runtime_logging.start(config={"dbname": "empty_database.db"})
print("Logging session ID: " + str(logging_session_id))

# Termination condition function
termination_msg = lambda x: isinstance(x, dict) and "TERMINATE" == str(x.get("content", ""))[-9:].upper()

llm_config = {
    "timeout": 600,
    "cache_seed": 44,
    "config_list": [{"model": "gpt-3.5-turbo", "api_key": os.environ["OPENAI_API_KEY"]}],
    "temperature": 0
}

# Define agents for interaction
manager_system_message = """
Manager. You interact with the user and delegate tasks to other agents based on the queries received. You cannot terminate without the user's consent.
"""
manager_agent = AssistantAgent(
    name="Manager",
    system_message=manager_system_message,
    is_termination_msg=termination_msg,
    code_execution_config=False,
    llm_config=llm_config,
    default_auto_reply="Reply TERMINATE if the task is done.",
    human_input_mode="ALWAYS",
)

sqluser_system_message = """
SQLuser. Based on the question from the manager_agent and existing database and metadata, you create relevant SQLite queries. You will not terminate the conversation by yourself.
"""
sqluser = AssistantAgent(
    name="SQLuser",
    system_message=sqluser_system_message,
    is_termination_msg=termination_msg,
    code_execution_config=False,
    llm_config=llm_config,
)

analyst_system_message = """
Analyst. You execute the queries generated by SQLuser, analyze the data, and provide results to the Manager for communication with the user. You will not terminate the conversation by yourself.
"""
analyst = AssistantAgent(
    name="Analyst",
    system_message=analyst_system_message,
    is_termination_msg=termination_msg,
    code_execution_config=False,
    llm_config=llm_config,
)

def fetch_metadata(json_file_paths: List[str]) -> Dict[str, Any]:
    combined_metadata = {}
    for json_file_path in json_file_paths:
        with open(json_file_path, 'r') as file:
            metadata = json.load(file)
            combined_metadata.update(metadata)
    return combined_metadata

def fetch_table_details(table_name: str, database_paths: List[str]) -> Dict[str, Any]:
    table_details = {
        "table_name": table_name,
        "columns": [],
        "primary_key": [],
        "foreign_keys": []
    }

    for database_path in database_paths:
        conn = sqlite3.connect(database_path)
        cursor = conn.cursor()

        cursor.execute(f"PRAGMA table_info({table_name})")
        columns = cursor.fetchall()
        column_names = [col[1] for col in columns]
        table_details["columns"].extend(column_names)

        primary_key = [col[1] for col in columns if col[5] == 1]
        table_details["primary_key"].extend(primary_key)

        cursor.execute(f"PRAGMA foreign_key_list({table_name})")
        foreign_keys = cursor.fetchall()
        table_details["foreign_keys"].extend(foreign_keys)

        conn.close()

    return table_details

def execute_query(query: str, database_paths: List[str]) -> List[Any]:
    results = []
    for database_path in database_paths:
        connection = sqlite3.connect(database_path)
        cursor = connection.cursor()
        try:
            cursor.execute(query)
            results.extend(cursor.fetchall())
        except Exception as e:
            results.append(str(e))
        finally:
            cursor.close()
            connection.close()
    return results

def call_rag_chat(problem_statement: str):
    # Extract paths and metadata files from DATABASES
    database_paths = [db["path"] for db in DATABASES]
    metadata_files = [db["metadata"] for db in DATABASES]

    # Reset agents
    manager_agent.reset()
    sqluser.reset()
    analyst.reset()

    # Register functions with specific agents for language model usage
    @manager_agent.register_for_llm(description="Fetch metadata from JSON files.", api_style="function")
    def fetch_metadata_llm() -> Dict[str, Any]:
        return fetch_metadata(metadata_files)

    @manager_agent.register_for_llm(description="Fetch table details from SQLite databases.", api_style="function")
    def fetch_table_details_llm(table_name: str) -> Dict[str, Any]:
        return fetch_table_details(table_name, database_paths)

    @manager_agent.register_for_llm(description="Execute SQL queries on the SQLite databases.", api_style="function")
    def execute_query_llm(query: str) -> List[Any]:
        return execute_query(query, database_paths)

    # Register functions for execution with relevant agents
    manager_agent.register_for_execution()(fetch_metadata)
    manager_agent.register_for_execution()(fetch_table_details)
    manager_agent.register_for_execution()(execute_query)

    sqluser.register_for_execution()(fetch_metadata)
    sqluser.register_for_execution()(fetch_table_details)
    sqluser.register_for_execution()(execute_query)

    analyst.register_for_execution()(fetch_metadata)
    analyst.register_for_execution()(fetch_table_details)
    analyst.register_for_execution()(execute_query)

    groupchat = GroupChat(
        agents=[manager_agent, sqluser, analyst],
        messages=[],
        max_round=12,
        speaker_selection_method="round_robin",
        allow_repeat_speaker=False,
    )

    manager = GroupChatManager(groupchat=groupchat, llm_config=llm_config)

    while True:
        manager_agent.initiate_chat(manager, message=problem_statement)
        user_input = input("Provide feedback to chat_manager. Type 'exit' to end the conversation: ")
        if user_input.lower() == 'exit':
            break
        manager_agent.send_message(manager, message=user_input)

# Example usage
if __name__ == "__main__":
    problem_statement = "What relevant questions can be asked to extract important data from these databases?"
    call_rag_chat(problem_statement)
